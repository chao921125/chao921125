<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>mouse event</title>
		<style>
			body, div {
				margin: 0;
                padding: 0;
			}
		</style>
	</head>
	<body>
        <p>side: <input id="side-input" value="8"></p>
        <p>dragPattern: <input id="dragPattern-input" type="checkbox"></p>
        <canvas id="my-canvas" width="500" height="500" style="border: solid 1px black">
    
        </canvas>
		
		<script type="text/javascript">
			    const
        canvas = document.getElementById('my-canvas'),
        sideInput = document.getElementById('side-input'),
        dragInput = document.getElementById('dragPattern-input');

    const
        canvasLeft = canvas.getBoundingClientRect().left,
        canvasTop = canvas.getBoundingClientRect().top,
        ctx = canvas.getContext('2d');

    let
        sideNum = sideInput.value, //ç»˜åˆ¶å¤šè¾¹å½¢çš„è¾¹æ•°ï¼Œé»˜è®¤ä¸º8
        dragPattern = dragInput.checked,//æ¨¡å¼é€‰æ‹©ï¼Œtrueä¸ºæ‹–æ‹½æ¨¡å¼ï¼Œfalseä¸ºç»˜åˆ¶æ¨¡å¼ï¼›é»˜è®¤ä¸ºfalse
        editIng = false, //æ˜¯å¦æ­£åœ¨ç”»å›¾
        mouseStart = new Map([
            ['x', null],
            ['y', null]
        ]),//è®°å½•é¼ æ ‡ç‚¹ä¸‹ä½ç½®
        polygonArray = [], //è®°å½•å¤šè¾¹å½¢è·¯å¾„çš„æ•°ç»„
        imageData = null, //ç”¨äºgetImageData()å’ŒputImageData()è®°å½•åŠç»˜åˆ¶å›¾åƒ
        draggingPolygon = null; //è®°å½•æ­£åœ¨æ‹–æ‹½çš„å¤šè¾¹å½¢

    // å¤šè¾¹å½¢è·¯å¾„ç±»å®šä¹‰
    class Polygon {
        constructor(centerX, centerY, sideNum, radius) {
            this.centerX = centerX;
            this.centerY = centerY;
            this.sideNum = sideNum;
            this.radius = radius;
        }
        createPath() {
            drawPolygonPath(
                this.sideNum,
                this.radius,
                this.centerX,
                this.centerY, ctx);
        }
    }

    /**
     * ç»˜åˆ¶å¤šè¾¹å½¢è·¯å¾„
     * sideNum:è¾¹æ•°
     * radiusï¼šåŠå¾„
     * originX, originYåŸç‚¹ä½ç½®
     */
    function drawPolygonPath(sideNum, radius, originX, originY, ctx) {
        ctx.beginPath();
        const unitAngle = Math.PI * 2 / sideNum; //è®¡ç®—å•å…ƒè§’åº¦

        let
            angle = 0, //åˆå§‹è§’åº¦
            xLength, yLength;
        // ctx.moveTo(originX, originY);
        for (let i = 0; i < sideNum; i++) { //éå†è®¡ç®—ç‚¹ï¼Œå¹¶lineTo()ç»˜åˆ¶è·¯å¾„
            xLength = radius * Math.cos(angle);
            yLength = radius * Math.sin(angle);
            ctx.lineTo(originX + xLength, originY - yLength);//ç»˜åˆ¶è·¯å¾„
            angle += unitAngle;
        }
        ctx.closePath();//é—­åˆè·¯å¾„ï¼Œä¹Ÿå¯åœ¨forå¾ªç¯ä¸­å¤šä¸€æ¬¡å¾ªç¯lineTo()è‡³èµ·ç‚¹
    }

    //è·å–åœ¨canvasä¸­çš„ç‚¹å‡»ä½ç½®
    function positionInCanvas(e, canvasLeft, canvasTop) {
      console.log('clientXï¼š',e.clientX);
      console.log('clientYï¼š',e.clientY);
      console.log('canvasLeftï¼š', canvasLeft);
      console.log('canvasTopï¼š', canvasTop);
        return {
            x: e.clientX - canvasLeft,
            y: e.clientY - canvasTop
        }
    }

    //è·å–ä¸¤ç‚¹ç›´çº¿è·ç¦»
    function getDistance(x1, y1, x2, y2) {
        return Math.sqrt(
            (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)
        );
    }

    sideInput.oninput = function () {
        sideNum = this.value;
    }

    dragInput.onchange = function () {
        dragPattern = this.checked;
    }

    canvas.onmousedown = function (e) {
        const pos = positionInCanvas(e, canvasLeft, canvasTop);//è·å–åœ¨canvasä¸­çš„åƒç´ ä½ç½®
        //è®°å½•é¼ æ ‡èµ·å§‹ç‚¹s
        mouseStart.set('x', pos.x);
        mouseStart.set('y', pos.y);

        if (dragPattern === false) {//ç”»å›¾æ¨¡å¼
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);//è®°å½•å½“å‰å›¾åƒ(å¸§)
            editIng = true;//å¼€å§‹ç”»å›¾

        } else {//æ‹–æ‹½æ¨¡å¼
            for (let polygon of polygonArray) {
                polygon.createPath();
                if (ctx.isPointInPath(mouseStart.get('x'), mouseStart.get('y'))) {
                    draggingPolygon = polygon;
                    return;
                }
            }
        }
    }
    canvas.onmousemove = function (e) {
        if (dragPattern === false && editIng === true) {//ç”»å›¾æ¨¡å¼
            // è·å–ä½ç½®åŠè®¡ç®—åŠå¾„
            const
                pos = positionInCanvas(e, canvasLeft, canvasTop),
                radius = getDistance(mouseStart.get('x'), mouseStart.get('y'), pos.x, pos.y);

            ctx.putImageData(imageData, 0, 0); //ç»˜åˆ¶è®°å½•çš„å›¾åƒ(å¸§)
            drawPolygonPath(sideNum, radius, mouseStart.get('x'), mouseStart.get('y'), ctx);//ç”»è·¯å¾„
            ctx.stroke();

        } else if (draggingPolygon !== null && dragPattern === true) {//æ‹–æ‹½æ¨¡å¼
            const
                pos = positionInCanvas(e, canvasLeft, canvasTop),
                diff = new Map([
                    ['offsetX', pos.x - mouseStart.get('x')],
                    ['offsetY', pos.y - mouseStart.get('y')]
                ]);

            /**
             * å¤„äºmousemoveé˜¶æ®µï¼Œæ‹–æ‹½æ˜¯åŸºäºç‚¹å‡»æ—¶çš„ä½ç½®ã€‚
             * è®°å½•è¢«æ‹–æ‹½å¤šè¾¹å½¢çš„åˆå§‹ä¸­å¿ƒä½ç½®ï¼Œåœ¨ç»˜åˆ¶è·¯å¾„ä¼šå¤åŸ
             * 
             * åœ¨mouseupæ—¶å†åˆ·æ–°æ–°çš„ä¸­å¿ƒä½ç½®
             * 
             * è¿™éƒ¨åˆ†æˆ‘å®åœ¨éš¾ä»¥æè¿°ğŸ˜•é€šè¿‡ä¸‹é¢ä¸¤ä¸ªä½ç½®çš„console.log(draggingPolygon)
             * å°±å¥½ç†è§£äº†ï¼Œä¹Ÿå¯ä»¥è¯•è¯•ä¸å¤åŸä¼šå‘ç”Ÿä»€ä¹ˆ
             */
            let
                tempCenterX = draggingPolygon.centerX,
                tempCenterY = draggingPolygon.centerY;

            draggingPolygon.centerX += diff.get('offsetX');
            draggingPolygon.centerY += diff.get('offsetY');

            console.log(draggingPolygon)
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let polygon of polygonArray) {
                drawPolygonPath(polygon.sideNum, polygon.radius, polygon.centerX, polygon.centerY, ctx);
                ctx.stroke();
            }

            // ç»§ç»­åŸºäºç‚¹å‡»æ—¶çš„ä½ç½®æ‹–åŠ¨ï¼Œè®¡ç®—
            draggingPolygon.centerX = tempCenterX;
            draggingPolygon.centerY = tempCenterY;
            console.log(draggingPolygon);
        }
    }

    canvas.onmouseup = function (e) {
        if (dragPattern === false && editIng === true) {//ç”»å›¾æ¨¡å¼
            const
                pos = positionInCanvas(e, canvasLeft, canvasTop),
                radius = getDistance(mouseStart.get('x'), mouseStart.get('y'), pos.x, pos.y);

            const polygon = new Polygon(mouseStart.get('x'), mouseStart.get('y'), sideNum, radius);

            polygonArray.push(polygon);//è®°å½•è·¯å¾„å¯¹è±¡
            editIng = false;//ç»“æŸç”»å›¾
        } else if (draggingPolygon !== null) {
            const
                pos = positionInCanvas(e, canvasLeft, canvasTop),
                offsetMap = new Map([
                    ['offsetX', pos.x - mouseStart.get('x')],
                    ['offsetY', pos.y - mouseStart.get('y')]
                ]);
            draggingPolygon.centerX += offsetMap.get('offsetX');
            draggingPolygon.centerY += offsetMap.get('offsetY');
            draggingPolygon = null;
        }
    }




		</script>
	</body>
</html>
